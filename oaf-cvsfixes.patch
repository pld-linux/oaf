--- oaf-0.6.7/configure.in	Wed Oct 24 20:42:54 2001
+++ oaf/configure.in	Fri Dec  7 19:27:02 2001
@@ -185,6 +185,7 @@
 	OAF_SLAY=oaf-slay
 	AC_PATH_PROG(PS_PATH, ps)
 	AC_CACHE_CHECK([for POSIX ps], ac_cv_prog_ps_posix, [
+		USER=${USER:-${LOGNAME:-`logname`}}
 		if $PS_PATH -U $USER -opid,args >/dev/null 2>&1; then
 			ac_cv_prog_ps_posix=yes
 		else
--- oaf-0.6.7/test/oaf-slay.in	Thu Oct 11 08:53:37 2001
+++ oaf/test/oaf-slay.in	Fri Dec  7 19:27:09 2001
@@ -43,7 +43,7 @@
 
 # Build ps command.
 #
-$username = $ENV{'USER'};
+$username = $ENV{USER} || $ENV{LOGNAME} || `logname`;
 chomp($username);
 
 @IF_POSIX_PS@ $ps_cmd = "@PS_PATH@ -U $username -opid,args";
--- oaf-0.6.7/oafd/od-corba.c	Tue Sep  4 06:07:43 2001
+++ oaf/oafd/od-corba.c	Fri Nov 16 00:20:37 2001
@@ -430,6 +430,7 @@
 	ODActivationInfo ai;
         OAF_GeneralError *errval;
         char *error_description;
+        CORBA_Environment retry_ev;
 
 	retval = CORBA_OBJECT_NIL;
 
@@ -455,6 +456,31 @@
 
 	if (si != NULL) {
 		retval = od_server_activate (si, &ai, servant->self, ev);
+                /* If we failed to activate - it may be because our
+                 * request re-entered _during_ the activation
+                 * process resulting in a second process being started
+                 * but failing to register - so we'll look up again here
+                 * to see if we can get it.
+                 * FIXME: we should not be forking redundant processes
+                 * while an activation of that same process is on the
+                 * stack.
+                 * FIXME: we only get away with this hack because we
+                 * try and fork another process & thus allow the reply
+                 * from the initial process to be handled in the event
+                 * loop.
+                 */
+
+                if (ev->_major != CORBA_NO_EXCEPTION) {
+                        CORBA_exception_init (&retry_ev);
+
+                        retval = od_get_active_server (servant, iid, ctx, &retry_ev);
+
+                        CORBA_exception_free (&retry_ev);
+
+                        if (retval != CORBA_OBJECT_NIL) {
+                                CORBA_exception_free (ev);
+                        }
+                }
         } else {
                 errval = OAF_GeneralError__alloc ();
 
